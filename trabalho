#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

// 1. Defini√ß√£o da Estrutura da Pe√ßa
typedef struct {
    char nome; // Tipo da pe√ßa ('I', 'O', 'T', 'L', etc.)
    int id;    // Identificador √∫nico da pe√ßa
} Peca;

// 2. Defini√ß√£o da Estrutura da Fila
#define TAMANHO_MAXIMO 5
typedef struct {
    Peca pecas[TAMANHO_MAXIMO];
    int frente; // √çndice do primeiro elemento
    int fim;    // √çndice da pr√≥xima posi√ß√£o livre
    int count;  // N√∫mero atual de elementos na fila
} FilaPecas;

// Vari√°vel global para garantir IDs √∫nicos para as pe√ßas
static int proximo_id_peca = 0;

// ----------------------------------------------------
// Fun√ß√µes de Suporte (Gerar Pe√ßa)
// ----------------------------------------------------

// Gera uma nova pe√ßa com tipo aleat√≥rio e ID √∫nico
Peca gerarPeca() {
    Peca novaPeca;
    
    // Tipos de pe√ßas dispon√≠veis no Tetris Stack
    char tipos[] = {'I', 'O', 'T', 'L', 'J', 'S', 'Z'};
    int numTipos = sizeof(tipos) / sizeof(tipos[0]);
    
    // Seleciona um tipo aleat√≥rio
    novaPeca.nome = tipos[rand() % numTipos]; 
    
    // Atribui o ID √∫nico e incrementa para a pr√≥xima pe√ßa
    novaPeca.id = proximo_id_peca++;
    
    return novaPeca;
}

// ----------------------------------------------------
// Fun√ß√µes de Fila
// ----------------------------------------------------

// Inicializa a fila, preenchendo-a com pe√ßas iniciais
void inicializarFila(FilaPecas *fila) {
    fila->frente = 0;
    fila->fim = 0;
    fila->count = 0;
    
    // Preenche a fila inicial com 5 pe√ßas
    for (int i = 0; i < TAMANHO_MAXIMO; i++) {
        Peca novaPeca = gerarPeca();
        fila->pecas[fila->fim] = novaPeca;
        fila->fim = (fila->fim + 1) % TAMANHO_MAXIMO;
        fila->count++;
    }
    
    printf("‚úÖ Fila inicializada com %d pe√ßas.\n", fila->count);
}

// Verifica se a fila est√° vazia
bool filaVazia(FilaPecas *fila) {
    return fila->count == 0;
}

// Verifica se a fila est√° cheia
bool filaCheia(FilaPecas *fila) {
    return fila->count == TAMANHO_MAXIMO;
}

// ----------------------------------------------------
// A√ß√£o 2: Inserir nova pe√ßa ao final da fila (enqueue)
// ----------------------------------------------------
void enqueue(FilaPecas *fila) {
    if (filaCheia(fila)) {
        printf("‚ùå ERRO: A fila de pe√ßas futuras est√° cheia (%d/%d). N√£o √© poss√≠vel adicionar mais pe√ßas.\n", fila->count, TAMANHO_MAXIMO);
        return;
    }
    
    Peca novaPeca = gerarPeca();
    
    // Insere a nova pe√ßa na posi√ß√£o 'fim'
    fila->pecas[fila->fim] = novaPeca;
    
    // Atualiza o √≠ndice 'fim' (circular)
    fila->fim = (fila->fim + 1) % TAMANHO_MAXIMO;
    fila->count++;
    
    printf("‚ûï PE√áA INSERIDA: [%c %d] adicionada ao final da fila.\n", novaPeca.nome, novaPeca.id);
}

// ----------------------------------------------------
// A√ß√£o 1: Jogar uma pe√ßa (dequeue)
// ----------------------------------------------------
Peca dequeue(FilaPecas *fila) {
    Peca pecaRemovida = {'\0', -1}; // Pe√ßa nula para erro
    
    if (filaVazia(fila)) {
        printf("‚ùå ERRO: A fila est√° vazia! N√£o h√° pe√ßas para jogar.\n");
        return pecaRemovida;
    }
    
    // Pega a pe√ßa na posi√ß√£o 'frente'
    pecaRemovida = fila->pecas[fila->frente];
    
    // Move o √≠ndice 'frente' para a pr√≥xima posi√ß√£o (circular)
    fila->frente = (fila->frente + 1) % TAMANHO_MAXIMO;
    fila->count--;
    
    printf("‚ûñ PE√áA JOGADA: Pe√ßa [%c %d] removida da frente da fila.\n", pecaRemovida.nome, pecaRemovida.id);
    
    // Ap√≥s jogar uma pe√ßa, o jogo adiciona automaticamente uma nova (troca)
    printf("üîÑ A√ß√£o de Troca: Fila reabastecida automaticamente.\n");
    enqueue(fila);
    
    return pecaRemovida;
}

// ----------------------------------------------------
// A√ß√£o 3: Exibir o estado atual da fila
// ----------------------------------------------------
void exibirFila(FilaPecas *fila) {
    printf("\n--- Confirme seu estado ---\n");
    
    if (filaVazia(fila)) {
        printf("Fila de pe√ßas: [VAZIA]\n");
        return;
    }
    
    printf("Fila de pe√ßas:");
    
    int i = fila->frente;
    int elementos_exibidos = 0;
    
    // Percorre a fila de forma circular
    while (elementos_exibidos < fila->count) {
        printf(" [%c %d]", fila->pecas[i].nome, fila->pecas[i].id);
        i = (i + 1) % TAMANHO_MAXIMO;
        elementos_exibidos++;
    }
    
    printf("\nTotal de pe√ßas: %d/%d (Frente: %d, Fim: %d)\n", 
           fila->count, TAMANHO_MAXIMO, fila->frente, fila->fim);
}

// ----------------------------------------------------
// Fun√ß√£o Principal
// ----------------------------------------------------
int main() {
    // Inicializa a semente do gerador de n√∫meros aleat√≥rios
    // Isso √© importante para que as pe√ßas geradas sejam diferentes a cada execu√ß√£o.
    srand(time(NULL));
    
    FilaPecas fila;
    inicializarFila(&fila);
    
    int opcao;
    
    do {
        exibirFila(&fila);
        
        printf("\nOp√ß√µes de a√ß√£o:\n");
        printf("C√≥digo\tA√ß√£o\n");
        printf("1\tJogar pe√ßa (dequeue)\n");
        printf("2\tInserir nova pe√ßa (enqueue)\n");
        printf("0\tSair\n");
        
        printf("Escolha uma a√ß√£o: ");
        if (scanf("%d", &opcao) != 1) {
            // Limpa o buffer de entrada em caso de erro (ex: usu√°rio digita letra)
            while (getchar() != '\n');
            opcao = -1; // For√ßa uma op√ß√£o inv√°lida
        }
        
        printf("\n");
        
        switch (opcao) {
            case 1:
                // Simula o ciclo: joga a pe√ßa da frente e adiciona uma nova
                dequeue(&fila); 
                break;
            case 2:
                // Adiciona uma nova pe√ßa manualmente (apenas se a fila n√£o estiver cheia)
                enqueue(&fila);
                break;
            case 0:
                printf("‚úÖ Saindo do simulador Tetris Stack. Fim do trabalho.\n");
                break;
            default:
                printf("‚ùå Op√ß√£o inv√°lida. Por favor, digite 1, 2 ou 0.\n");
                break;
        }
        
        printf("\n----------------------------------------------------\n");
        
    } while (opcao != 0);
    
    return 0;
}